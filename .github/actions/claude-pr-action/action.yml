name: Deploy

on:
  push:
    branches:
      - develop
      - staging
      - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  GHA_CACHE_KEEP_DAYS: 7
  GHA_CACHE_KEEP_MAX: 10
 
jobs:
  # Job to detect which services need to be built
  changes:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      authentication: ${{ steps.filter.outputs.authentication }}
      web: ${{ steps.filter.outputs.web }}
      backend: ${{ steps.filter.outputs.backend }}
      packages: ${{ steps.filter.outputs.packages }}
      workflows: ${{ steps.filter.outputs.workflows }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            authentication:
              - 'authentication/**'
              - 'packages/**'
              - 'package.json'
              - 'bun.lock'
              - 'Dockerfile'
              - 'docker-compose.yaml'
            web:
              - 'apps/web/**'
              - 'packages/**'
              - 'package.json'
              - 'bun.lock'
              - 'Dockerfile'
              - 'docker-compose.yaml'
            backend:
              - 'backend/**'
              - 'packages/**'
              - 'package.json'
              - 'bun.lock'
              - 'Dockerfile'
              - 'docker-compose.yaml'
              - 'infra.config.json'
            workflows:
              - 'workflows/**'
              - 'packages/**'
              - 'package.json'
              - 'bun.lock'
              - 'Dockerfile'
              - 'docker-compose.yaml'
            packages:
              - 'packages/**'
              - 'package.json'
              - 'bun.lock'
              - '*.json'
              - '*.yaml'
              - '*.yml'

  Authentication:
    needs: changes
    if: ${{ needs.changes.outputs.authentication == 'true' }}
    environment: ${{ github.ref_name }}
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to the Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_TOKEN }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ github.ref_name }}/authentication
          tags: |
            type=raw,value=latest
            type=sha,prefix={{date 'YYYYMMDD'}}-            

      - name: Build and push
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./authentication/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha,scope=${{ env.IMAGE_NAME }}-${{ github.ref_name }}-authentication
            type=gha,scope=${{ env.IMAGE_NAME }}-${{ github.ref_name }}-authentication-buildkit
          cache-to: |
            type=gha,mode=max,scope=${{ env.IMAGE_NAME }}-${{ github.ref_name }}-authentication
            type=gha,mode=max,scope=${{ env.IMAGE_NAME }}-${{ github.ref_name }}-authentication-buildkit
          platforms: linux/arm64
          provenance: false
          sbom: false
          build-args: |
            AUTH_DATABASE_URL=${{ secrets.AUTH_DATABASE_URL }}
            AUTH_SECRET=${{ secrets.AUTH_SECRET }}
            AUTH_DATABASE_SSL=${{ secrets.AUTH_DATABASE_SSL }}
            PRIMARY_DOMAIN=${{ secrets.PRIMARY_DOMAIN }}
            GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
            GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
            GOOGLE_REDIRECT_URI=${{ secrets.GOOGLE_REDIRECT_URI }}
            AWS_REGION=${{ secrets.AWS_REGION }}
            AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            EMAIL_FROM=${{ secrets.EMAIL_FROM }}
            TURNSTILE_SECRET_KEY=${{ secrets.TURNSTILE_SECRET_KEY }}
            NEXT_PUBLIC_TURNSTILE_SITE_KEY=${{ secrets.NEXT_PUBLIC_TURNSTILE_SITE_KEY }}
           
  Web:
    needs: changes
    if: ${{ needs.changes.outputs.web == 'true' }}
    environment: ${{ github.ref_name }}
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to the Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_TOKEN }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ github.ref_name }}/web
          tags: |
            type=raw,value=latest
            type=sha,prefix={{date 'YYYYMMDD'}}-            

      - name: Build and push
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./apps/web/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # cache-from: |
          #   type=gha,scope=${{ github.ref_name }}-web
          #   type=gha,scope=${{ github.ref_name }}-web-buildkit
          # cache-to: |
          #   type=gha,mode=max,scope=${{ github.ref_name }}-web
          #   type=gha,mode=max,scope=${{ github.ref_name }}-web-buildkit
          platforms: linux/arm64
          # provenance: false
          # sbom: false
          build-args: |
            NEXT_PUBLIC_PRIMARY_DOMAIN=${{ secrets.NEXT_PUBLIC_PRIMARY_DOMAIN }}
            NEXT_PUBLIC_PORT=${{ secrets.NEXT_PUBLIC_PORT }}
            NEXT_PUBLIC_AUTH_URL_ARG=${{ secrets.NEXT_PUBLIC_AUTH_URL }}
            NEXT_PUBLIC_ENCORE_API_URL=${{ secrets.NEXT_PUBLIC_ENCORE_API_URL }}
            NEXT_PUBLIC_TURNSTILE_SITE_KEY=${{ secrets.NEXT_PUBLIC_TURNSTILE_SITE_KEY }}
            AUTH_SECRET=${{ secrets.AUTH_SECRET }}
            BETTER_AUTH_URL=${{ secrets.BETTER_AUTH_URL }}
            NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=${{ secrets.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY }}
    
  # Backend:
  #   needs: changes
  #   if: ${{ needs.changes.outputs.backend == 'true' }}
  #   environment: ${{ github.ref_name }}
  #   runs-on: ubuntu-latest
  #   # runs-on: self-hosted
  #   permissions:
  #     contents: read
  #     packages: write

  #   outputs:
  #     image-digest: ${{ steps.build.outputs.digest }}
  #     image-tags: ${{ steps.meta.outputs.tags }}

  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
      
  #     - name: Setup Docker Buildx
  #       uses: docker/setup-buildx-action@v3      

  #     - name: Login to the Container Registry
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ${{ env.REGISTRY }}
  #         username: ${{ secrets.GHCR_TOKEN }}
  #         password: ${{ secrets.GHCR_TOKEN }}

  #     - name: Extract metadata
  #       id: meta
  #       uses: docker/metadata-action@v5
  #       with:
  #         images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ github.ref_name }}/backend
  #         tags: |
  #           type=raw,value=latest
  #           type=sha,prefix={{date 'YYYYMMDD'}}-            

  #     - name: Build and push
  #       id: build
  #       uses: docker/build-push-action@v6
  #       with:
  #         context: .
  #         file: ./backend/Dockerfile
  #         push: true
  #         tags: ${{ steps.meta.outputs.tags }}
  #         labels: ${{ steps.meta.outputs.labels }}
  #         # cache-from: |
  #         #   type=gha,scope=${{ github.ref_name }}-backend
  #         #   type=gha,scope=${{ github.ref_name }}-backend-buildkit
  #         # cache-to: |
  #         #   type=gha,mode=max,scope=${{ github.ref_name }}-backend
  #         #   type=gha,mode=max,scope=${{ github.ref_name }}-backend-buildkit
  #         platforms: linux/arm64
  #         # provenance: false
  #         # sbom: false
  #         build-args: |
  #           NODE_TLS_REJECT_UNAUTHORIZED=${{ vars.NODE_TLS_REJECT_UNAUTHORIZED }}
  #           DATABASE_URL=${{ secrets.DATABASE_URL }}
  #           AUTH_BASE_URL_ARG=${{ secrets.AUTH_BASE_URL }}

  Backend:
    needs: changes
    if: ${{ needs.changes.outputs.backend == 'true' }}
    environment: ${{ github.ref_name }}
    runs-on: self-hosted
    # runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
    steps:
        - name: Checkout
          uses: actions/checkout@v4

        - name: Install Go
          uses: actions/setup-go@v5
          with:
            go-version: '1.21'

        - name: Install Encore CLI
          run: |
            curl -L https://encore.dev/install.sh | bash
            echo "$HOME/.encore/bin" >> $GITHUB_PATH

        - name: Install Bun
          uses: oven-sh/setup-bun@v2

        - name: Login to the Container Registry
          uses: docker/login-action@v3
          with:
            registry: ${{ env.REGISTRY }}
            username: ${{ secrets.GHCR_TOKEN }}
            password: ${{ secrets.GHCR_TOKEN }}
            
        - name: Extract metadata
          id: meta
          uses: docker/metadata-action@v5
          with:
            images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ github.ref_name }}/backend
            tags: |
              type=raw,value=latest
          
        - name: Build with Encore and push to GitHub Container Registry
          env:
            NODE_TLS_REJECT_UNAUTHORIZED: ${{ vars.NODE_TLS_REJECT_UNAUTHORIZED }}
            DATABASE_URL: ${{ secrets.DATABASE_URL }}
            AUTH_BASE_URL_ARG: ${{ secrets.AUTH_BASE_URL }}
            BUCKET_SECRET_ACCESS_KEY: ${{ secrets.BUCKET_SECRET_ACCESS_KEY }}
            POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          run: |
            # Change to the /backend directory
            cd backend

            # Run bun install
            bun install

            # Run encore build
            encore build docker --config infra.config.json ${{ steps.meta.outputs.tags }} --arch arm64 --base oven/bun:1.2.17-debian 

            # Push the image to the GitHub Container Registry
            docker push ${{ steps.meta.outputs.tags }}
            
            # Get the image digest for output
            DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ steps.meta.outputs.tags }} | cut -d'@' -f2)
            echo "digest=$DIGEST" >> $GITHUB_OUTPUT
            
  Workflows:
    needs: changes
    if: ${{ needs.changes.outputs.workflows == 'true' }}
    environment: ${{ github.ref_name }}
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to the Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_TOKEN }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ github.ref_name }}/workflows
          tags: |
            type=raw,value=latest
            type=sha,prefix={{date 'YYYYMMDD'}}-            

      - name: Build and push
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./workflows
          file: ./workflows/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # cache-from: type=gha,scope=${{ github.ref_name }}-workflows
          # cache-to: type=gha,mode=max,scope=${{ github.ref_name }}-workflows
          platforms: linux/arm64
          build-args: |
            HATCHET_CLIENT_TOKEN=${{ secrets.HATCHET_CLIENT_TOKEN }}
            HATCHET_CLIENT_TLS_STRATEGY=${{ secrets.HATCHET_CLIENT_TLS_STRATEGY }}
            HATCHET_CLIENT_HOST=${{ secrets.HATCHET_CLIENT_HOST }}
            AWS_ACCESS_KEY_ID=${{ vars.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            AWS_DEFAULT_REGION=${{ vars.AWS_DEFAULT_REGION }}
            TARGET_BUCKET_NAME=${{ vars.TARGET_BUCKET_NAME }}
            DATABASE_URL=${{ secrets.DATABASE_URL }}          
            
  Trigger-dokploy-deployment:
    needs: [changes, Authentication, Web, Backend, Workflows]
    if: |
      always() && 
      !cancelled() && 
      (needs.changes.outputs.authentication == 'true' || 
       needs.changes.outputs.web == 'true' || 
       needs.changes.outputs.backend == 'true' ||
       needs.changes.outputs.workflows == 'true')
    environment: ${{ github.ref_name }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Trigger Dokploy Deployment
        run: |
          # Stop the current containers
          curl -X 'POST' \
            'http://${{ vars.DOKPLOY_URL }}/api/trpc/compose.stop' \
            -H 'x-api-key: ${{ secrets.DOKPLOY_AUTH_TOKEN }}' \
            -H 'Content-Type: application/json' \
            -d '{"json":{"composeId": "${{ vars.DOKPLOY_COMPOSE_ID }}"}}'

          # Wait for the contaiers to stop
          sleep 15

          # Deploy the new containers
          response=$(curl -s -w "%{http_code}" -X 'POST' \
            'http://${{ vars.DOKPLOY_URL }}/api/trpc/compose.deploy' \
            -H 'accept: application/json' \
            -H 'x-api-key: ${{ secrets.DOKPLOY_AUTH_TOKEN }}' \
            -H 'Content-Type: application/json' \
            -d '{"json":{"composeId": "${{ vars.DOKPLOY_COMPOSE_ID }}"}}')
          
          status_code=${response: -3}
          if [[ "$status_code" != "200" ]]; then
            echo "Dokploy API call failed with status code: $status_code"
            echo "Response: ${response%???}"
            exit 1
          fi   

  Clean-cache:
    needs: [changes, Authentication, Web, Backend, Workflows]
    if: |
      always() && 
      !cancelled() && 
      (needs.changes.outputs.authentication == 'true' || 
       needs.changes.outputs.web == 'true' || 
       needs.changes.outputs.backend == 'true' ||
       needs.changes.outputs.workflows == 'true')
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Cleanup Authentication caches
        if: needs.changes.outputs.authentication == 'true'
        run: |
          gh extension install actions/gh-actions-cache
          
          REPO=${{ github.repository }}
          BRANCH="${{ github.ref_name }}"
          CACHE_KEY_PREFIX="${BRANCH}-authentication"
          
          echo "Repository: $REPO"
          echo "Branch: $BRANCH"
          echo "Looking for cache keys starting with: $CACHE_KEY_PREFIX"
          
          # List all caches and filter by our prefix
          echo "Fetching all caches..."
          gh actions-cache list -R $REPO --sort created-at --order desc > all_caches.txt
          
          echo "All caches found:"
          cat all_caches.txt
          
          # Filter caches that match our pattern
          echo "Filtering caches for pattern: $CACHE_KEY_PREFIX"
          cacheKeys=$(grep "$CACHE_KEY_PREFIX" all_caches.txt | awk '{print $1}' || echo "")
          
          if [ -z "$cacheKeys" ]; then
            echo "No caches found matching pattern: $CACHE_KEY_PREFIX"
          else
            echo "Found matching caches:"
            echo "$cacheKeys"
            
            # Count the caches
            cacheCount=$(echo "$cacheKeys" | wc -l)
            echo "Total matching cache count: $cacheCount"
            
            # Keep only the 10 most recent caches
            if [ "$cacheCount" -gt "${{ env.GHA_CACHE_KEEP_MAX }}" ]; then
              # Keep the most recent caches based on GHA_CACHE_KEEP_MAX
              cachesToDelete=$(echo "$cacheKeys" | tail -n $(($cacheCount - ${{ env.GHA_CACHE_KEEP_MAX }})))
              
              echo "Caches to delete:"
              echo "$cachesToDelete"
              
              # Delete older caches
              for cacheKey in $cachesToDelete; do
                echo "Deleting cache key: $cacheKey"
                gh actions-cache delete "$cacheKey" -R $REPO --confirm || echo "Failed to delete $cacheKey"
              done
            else
              echo "No cache pruning needed. Current cache count: $cacheCount (max: ${{ env.GHA_CACHE_KEEP_MAX }})"
            fi
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Cleanup Web caches
        if: needs.changes.outputs.web == 'true'
        run: |
          gh extension install actions/gh-actions-cache
          
          REPO=${{ github.repository }}
          BRANCH="${{ github.ref_name }}"
          CACHE_KEY_PREFIX="${BRANCH}-web"
          
          echo "Repository: $REPO"
          echo "Branch: $BRANCH"
          echo "Looking for cache keys starting with: $CACHE_KEY_PREFIX"
          
          # List all caches and filter by our prefix
          echo "Fetching all caches..."
          gh actions-cache list -R $REPO --sort created-at --order desc > all_caches.txt
          
          echo "All caches found:"
          cat all_caches.txt
          
          # Filter caches that match our pattern
          echo "Filtering caches for pattern: $CACHE_KEY_PREFIX"
          cacheKeys=$(grep "$CACHE_KEY_PREFIX" all_caches.txt | awk '{print $1}' || echo "")
          
          if [ -z "$cacheKeys" ]; then
            echo "No caches found matching pattern: $CACHE_KEY_PREFIX"
          else
            echo "Found matching caches:"
            echo "$cacheKeys"
            
            # Count the caches
            cacheCount=$(echo "$cacheKeys" | wc -l)
            echo "Total matching cache count: $cacheCount"
            
            # Keep only the 10 most recent caches
            if [ "$cacheCount" -gt "${{ env.GHA_CACHE_KEEP_MAX }}" ]; then
              # Keep the most recent caches based on GHA_CACHE_KEEP_MAX
              cachesToDelete=$(echo "$cacheKeys" | tail -n $(($cacheCount - ${{ env.GHA_CACHE_KEEP_MAX }})))
              
              echo "Caches to delete:"
              echo "$cachesToDelete"
              
              # Delete older caches
              for cacheKey in $cachesToDelete; do
                echo "Deleting cache key: $cacheKey"
                gh actions-cache delete "$cacheKey" -R $REPO --confirm || echo "Failed to delete $cacheKey"
              done
            else
              echo "No cache pruning needed. Current cache count: $cacheCount (max: ${{ env.GHA_CACHE_KEEP_MAX }})"
            fi
          fi
        env:
          GH_TOKEN: ${{ github.token }}
          
      - name: Cleanup Workflows caches
        if: needs.changes.outputs.backend == 'true'
        run: |
          gh extension install actions/gh-actions-cache
          
          REPO=${{ github.repository }}
          BRANCH="${{ github.ref_name }}"
          CACHE_KEY_PREFIX="${BRANCH}-workflows"
          
          echo "Repository: $REPO"
          echo "Branch: $BRANCH"
          echo "Looking for cache keys starting with: $CACHE_KEY_PREFIX"
          
          # List all caches and filter by our prefix
          echo "Fetching all caches..."
          gh actions-cache list -R $REPO --sort created-at --order desc > all_caches.txt
          
          echo "All caches found:"
          cat all_caches.txt
          
          # Filter caches that match our pattern
          echo "Filtering caches for pattern: $CACHE_KEY_PREFIX"
          cacheKeys=$(grep "$CACHE_KEY_PREFIX" all_caches.txt | awk '{print $1}' || echo "")
          
          if [ -z "$cacheKeys" ]; then
            echo "No caches found matching pattern: $CACHE_KEY_PREFIX"
          else
            echo "Found matching caches:"
            echo "$cacheKeys"
            
            # Count the caches
            cacheCount=$(echo "$cacheKeys" | wc -l)
            echo "Total matching cache count: $cacheCount"
            
            # Keep only the 10 most recent caches
            if [ "$cacheCount" -gt "${{ env.GHA_CACHE_KEEP_MAX }}" ]; then
              # Keep the most recent caches based on GHA_CACHE_KEEP_MAX
              cachesToDelete=$(echo "$cacheKeys" | tail -n $(($cacheCount - ${{ env.GHA_CACHE_KEEP_MAX }})))
              
              echo "Caches to delete:"
              echo "$cachesToDelete"
              
              # Delete older caches
              for cacheKey in $cachesToDelete; do
                echo "Deleting cache key: $cacheKey"
                gh actions-cache delete "$cacheKey" -R $REPO --confirm || echo "Failed to delete $cacheKey"
              done
            else
              echo "No cache pruning needed. Current cache count: $cacheCount (max: ${{ env.GHA_CACHE_KEEP_MAX }})"
            fi
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Cleanup Backend caches
        if: needs.changes.outputs.backend == 'true'
        run: |
          gh extension install actions/gh-actions-cache
          
          REPO=${{ github.repository }}
          BRANCH="${{ github.ref_name }}"
          CACHE_KEY_PREFIX="${BRANCH}-backend"
          
          echo "Repository: $REPO"
          echo "Branch: $BRANCH"
          echo "Looking for cache keys starting with: $CACHE_KEY_PREFIX"
          
          # List all caches and filter by our prefix
          echo "Fetching all caches..."
          gh actions-cache list -R $REPO --sort created-at --order desc > all_caches.txt
          
          echo "All caches found:"
          cat all_caches.txt
          
          # Filter caches that match our pattern
          echo "Filtering caches for pattern: $CACHE_KEY_PREFIX"
          cacheKeys=$(grep "$CACHE_KEY_PREFIX" all_caches.txt | awk '{print $1}' || echo "")
          
          if [ -z "$cacheKeys" ]; then
            echo "No caches found matching pattern: $CACHE_KEY_PREFIX"
          else
            echo "Found matching caches:"
            echo "$cacheKeys"
            
            # Count the caches
            cacheCount=$(echo "$cacheKeys" | wc -l)
            echo "Total matching cache count: $cacheCount"
            
            # Keep only the 10 most recent caches
            if [ "$cacheCount" -gt "${{ env.GHA_CACHE_KEEP_MAX }}" ]; then
              # Keep the most recent caches based on GHA_CACHE_KEEP_MAX
              cachesToDelete=$(echo "$cacheKeys" | tail -n $(($cacheCount - ${{ env.GHA_CACHE_KEEP_MAX }})))
              
              echo "Caches to delete:"
              echo "$cachesToDelete"
              
              # Delete older caches
              for cacheKey in $cachesToDelete; do
                echo "Deleting cache key: $cacheKey"
                gh actions-cache delete "$cacheKey" -R $REPO --confirm || echo "Failed to delete $cacheKey"
              done
            else
              echo "No cache pruning needed. Current cache count: $cacheCount (max: ${{ env.GHA_CACHE_KEEP_MAX }})"
            fi
          fi
        env:
          GH_TOKEN: ${{ github.token }}             

      